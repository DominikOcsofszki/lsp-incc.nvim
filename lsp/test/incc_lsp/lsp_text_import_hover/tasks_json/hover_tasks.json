{
"task0": "Zum warm werden: Lexer für Algol60 (Verpflichtend)",
"task1": "Arithmetische und Boole'sche Ausdrücke (Verpflichtend)",
"task2": "Variablen und Sequenzierung (Verpflichtend)\nErweitern Sie Ihre Sprache um die Möglichkeit Ausdrücke zu sequenzieren.\n\nDie folgende Syntax soll dabei implementiert werden, d.h. Ausdücke sollen durch Semikolon getrennt werden und die Sequenz in geschweifte Klammern eingeschlossen werden\n\nBeispiel:\n\n{ a:=0; b:=a+b }\n",
"task3": "If-Then-Else, Loop und For-Schleife (Verpflichtend) Implementieren Sie Kontrollstrukturen für bedingte Ausführung und Schleifenkonstrukte:\n\nIf then else soll die folgende Syntax besitzen:\n\nIT:    if condition then expr\n\nITE: if condition then expr else expr\n\nFalls die condition zutrifft soll der Wert der IT-Anweisung undefiniert (None) sein, ansonsten der Wert des entsprechenden Ausdrucks.\n\nLoop-Schleifen sollen die folgende Syntax besitzten:\n\nLoop var expr\n\nDer Ausdruck expr wird so oft ausgeführt, wie der Wert von var zu Beginn der Schleife ist. Rückgabewert ist der Wert der letzten Auswertung der expr. Falls der Wert von var=0 ist, dann ist der Rückgagbewert None.\n\nFor-Schleifen sollen die folgende Syntax besitzen:\n\nFor assignment; condition; assignment do expr\n\nDie Semantik enspricht der C-Schleifensemantik, der Rückgabewert ist der Wert der letzten Auswertung des Schleifenkörpers, oder None, wenn die Schleife nicht betreten wird.\n\nOptional:\n\nLock-Statement\n\nlock var expr\n\nverhindert (prüft), dass expr var einen neuen Wert zuweist.\n ",
"task4": "While-Schleife und Locale Scopes (Verpflichtend)\nErweitern Sie Ihre Sprache um eine While Schleife mit der folgenden Syntax\n\nwhile condition do expr\n\nSementik wie die entsprechende For-Schleife.\n\nErweitern Sie die Sprache um lokale Variablen-Bindings. Syntax:\n\nlocal assignment in expr\n\nImplementieren Sie hierzu ein hierarchisches Environment (z.B. auf Basis eines dicts). Rückgabewert ist der Wert der Expression. Änderungen an den umgebenden Environments durch expr müssen in diesen Environments erfolgen.",
"task5": "Lambda-Ausdücke und rekursives local-Statement (Verpflichtend)\nImpementieren Sie Lambda-Ausdrücke mit der Syntax:\n\nvar -> body\n\nachten Sie darauf, dass die Ausdrücke ohne Klammersetzung Variablen zugewiesen werden können also f := x -> x*x sollte syntaktisch korrekt sein.\n\nDer Aufruf eines Lambda Ausdrucks \"f\" erfolgt durch\n\nf(val)\n\nÜberarbeiten Sie Ihre Implementierung des \"local\" Statements so, dass rekursiv definierte Funktionen als lokale Variable möglich sind.\n\nImplementieren Sie in Ihrer Programmiersprache einen counter, also eine Funktion, die folgendes Verhalten zeigt:\n\nc := counter(0);\n\nc(1) -> 1\n\nc(1) -> 2\n\nc(1) -> 3\n\nc(2) -> 5\n\nc(3) -> 8",
"task6": "n-stellige Funktionen und elementare Datentypen (Verpflichtend)\n Implementieren Sie n-stellige lambda-Ausdrücke sowie deren Aufruf.\n\nDie Syntax soll wie folgt sein:\n\nf := x,y -> expr # zweistellig\nf := -> expr     # nullstellig\n\nAufrufe:\n\nf()\n\nf(x,z,s)\n\nErweitern Sie die möglichen Datentypen um die folgenden Typen mit der jeweils gezeigten Syntax:\n\nString: \"asdf\"\nChar:   'a'\nFloat:  3.1415 (auch .3 und 3.)\n\nListen:  list(1,2,3)\n\nmit den Funktionen\n\nhead(l), tail(l)\n\nsowie\n\nArray:   [1,2,3] (optional array(1,2,3))\n\nmit dem Zugriff über eckige Klammern:\n\na[i] für zugriff auf i-tes element, 0-basiert\n",
"task7": "Beutzerdefinierte Strukturen (Verpflichtend)\n Imlementieren Sie benutzterdefinierte structs für Ihre Programmiersprache. Die Syntax soll wie folgt aussehen:\n\n\na:=5;\n\ns := struct {\n\n   x := 1;\n\n   y := a;\n\n   f := lambda (x)  a:=x\n\n}\n\nstructs definieren einen neuen scope im aktuellen lexical scope. Der Wert des Structs ist dieser Scope. Innerhalb des structs kann auf die Variablen des lexical scopes zugegriffen werden. Diese werden aber nicht \"exposed\", also `s.a` ist nicht definiert.\n\nDer Zugriff auf die Members des structs erfolgt über Punkt-Notation:\n\ns.x\n\ns.f(3)\n\nstructs können erweitert werden:\n\nt := extend s { z:=4; x:=4711 }\n\nDabei wird das \"Basis\"-Struct erweitert. D.h. es wird eine neue Umgebung erzeugt, die einen Verweis auf die übergeordnetet (in diesem Fall s) enthält. Bei überladenen Attibuten kann auf die übergeordeten Attribute per Punkt-Notation zugegriffen werden:\n\nt.x => 4711\n\nt..x => 1\n\nBei mehrfachen Erweiterungen sind entsprechend viele Punkte zu verwenden: z.B. s....x\n\nInnerhalbt eines Stucts kann man auf .x, ..x usw. zugreifen (wobei .x identisch zu x ist).\n\n(siehe auch Tafelanschrieb  in der Anlage zur Aufgabenstellung)"
}
